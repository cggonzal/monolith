<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>CSRF Protection — Monolith Guides</title>
<link href="stylesheets/style.css" rel="stylesheet" type="text/css"/>
</head>
<body class="guide">
<header id="page-header">
<div class="wrapper clearfix">
<nav id="feature-nav">
<div class="header-logo">
<a href="index.html">Monolith Guides</a>
</div>
</nav>
</div>
</header>
<main id="main">
<article>
<header id="feature">
<div class="wrapper">
<h1>CSRF Protection</h1>
<p>Cross-site request forgery mitigation powered by Go 1.25&rsquo;s built-in cross-origin protection.</p>
<nav aria-label="Chapter" class="guide-index" id="column-side"><a class="skip-link" href="#article-body" id="chapter-nav-skip-link">Skip to article body</a><h2 class="chapter"><picture aria-hidden="true"><img alt="Chapter Icon" src="images/icon_book-close-bookmark-1.svg"/></picture> Chapters</h2><ol class="chapters"><li><a href="#built-in-protection">Built-in Protection</a></li><li><a href="#enabling-middleware">Enabling the Middleware</a></li><li><a href="#trusted-origins">Trusted Origins &amp; Bypasses</a></li><li><a href="#denied-requests">Handling Denied Requests</a></li></ol></nav></div>
</header>
<div class="wrapper" id="article-body">
<p>Monolith now relies on Go 1.25&rsquo;s <code>net/http.CrossOriginProtection</code> to block forged browser requests. Instead of minting per-session tokens, the middleware inspects the <code>Origin</code> and <code>Sec-Fetch-Site</code> headers that modern browsers attach to cross-site navigations. Unsafe requests that originate from a different site are rejected with <code>403 Forbidden</code> before they reach your handlers.</p>
<h2 id="built-in-protection"><a class="anchorlink" data-turbo="false" href="#built-in-protection"><span>1.</span> Built-in Protection</a></h2>
<p><code>http.CrossOriginProtection</code> trusts same-origin navigation automatically. Safe HTTP verbs (<code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>) are always allowed, so ensure state-changing work only happens on unsafe methods. Requests without <code>Origin</code> or <code>Sec-Fetch-Site</code> headers are treated as same-origin so API clients and command-line tools continue to function.</p>
<h2 id="enabling-middleware"><a class="anchorlink" data-turbo="false" href="#enabling-middleware"><span>2.</span> Enabling the Middleware</a></h2>
<p>The <code>middleware.CSRFMiddleware</code> helper wraps a shared <code>CrossOriginProtection</code> instance around your router. Because protection now lives entirely in middleware, controllers and templates no longer need to render hidden inputs or meta tags.</p>
<pre><code class="highlight go">mux := http.NewServeMux()
registerRoutes(mux, staticFiles)
handler := middleware.CSRFMiddleware(middleware.LoggingMiddleware(mux))
return handler</code></pre>
<p>That single wrapper covers form posts, AJAX requests, and programmatic clients without requiring per-request tokens.</p>
<h2 id="trusted-origins"><a class="anchorlink" data-turbo="false" href="#trusted-origins"><span>3.</span> Trusted Origins &amp; Bypasses</a></h2>
<p>If you embed Monolith endpoints inside another trusted domain, call <code>AddTrustedOrigin</code> on the shared protector. You can also permit machine-to-machine callbacks with <code>AddInsecureBypassPattern</code> for specific routes. Both methods are safe to call during initialization.</p>
<pre><code class="highlight go">func init() {
    middleware.CrossOriginProtector().AddTrustedOrigin("https://admin.example.com")
}</code></pre>
<p>Only add bypass patterns for endpoints that never run in a browser context (such as webhooks) because they disable CSRF enforcement for those paths.</p>
<h2 id="denied-requests"><a class="anchorlink" data-turbo="false" href="#denied-requests"><span>4.</span> Handling Denied Requests</a></h2>
<p>When a request fails cross-origin checks the middleware responds with <code>403 Forbidden</code> and logs the relevant headers. Override the deny handler when you need JSON responses or custom messaging.</p>
<pre><code class="highlight go">protector := middleware.CrossOriginProtector()
protector.SetDenyHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    http.Error(w, "Cross-origin request blocked", http.StatusForbidden)
}))</code></pre>
<p>With Go 1.25&rsquo;s standard library protections in place, CSRF defense becomes a middleware concern and your templates stay free of hidden fields.</p>
</div>
</article>
</main>
</body>
</html>
